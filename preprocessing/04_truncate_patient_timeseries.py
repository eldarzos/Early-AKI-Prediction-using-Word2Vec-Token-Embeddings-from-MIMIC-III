"""
Step 4: Truncate Timeseries

Truncate episode timeseries data to a specified input length (input_hours).

- Filters stays shorter than input_hours and clips events occurring after input_hours
- Creates a combined ITEMID_UOM identifier
- Saves output as episode{i}_timeseries_{input_hours}.csv

Usage:
    python 04_truncate_timeseries.py [--input_hours 24]
    
Make sure to run Steps 1-3 first.
"""

import argparse
import numpy as np
import os
import pandas as pd
from tqdm import tqdm
import logging
import sys

# Add config to path
sys.path.append('../config')
from config import *

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s [%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)

def truncate_timeseries(root_dir, input_hours):
    """Truncates timeseries files in subject directories to input_hours."""
    subjects = [d for d in os.listdir(root_dir) if os.path.isdir(os.path.join(root_dir, d)) and d.isdigit()]
    logger.info(f"Found {len(subjects)} subject directories.")

    patient_count = 0  # Subjects with at least one valid stay >= input_hours
    stay_count = 0     # Stays >= input_hours with events within the window
    event_count = 0    # Events within the input_hours window across all valid stays

    itemids = set()
    uoms = set()
    itemid_uoms = set()

    for subject in tqdm(subjects, desc=f"Truncating timeseries to {input_hours}h"):
        subject_dir = os.path.join(root_dir, subject)
        # Find episode files (episode*.csv) and corresponding FULL timeseries (episode*_timeseries.csv)
        episode_files = sorted([f for f in os.listdir(subject_dir) 
                               if f.startswith('episode') and f.endswith('.csv') and 'timeseries' not in f])

        subject_has_valid_stay = False

        for ep_file in episode_files:
            episode_num = ep_file.split('episode')[1].split('.csv')[0]
            # Input is the FULL timeseries generated by script 3
            ts_file = f'episode{episode_num}_timeseries.csv'
            ep_path = os.path.join(subject_dir, ep_file)
            ts_path = os.path.join(subject_dir, ts_file)

            if not os.path.exists(ts_path) or not os.path.exists(ep_path):
                continue

            try:
                # Read episode data to check Length of Stay (LOS)
                episode_data = pd.read_csv(ep_path)
                if episode_data.empty: 
                    continue

                los_days = episode_data['Length of Stay'].iloc[0]
                if pd.isna(los_days): 
                    continue

                los_hours = los_days * 24.0
                # Filter stays shorter than the required INPUT duration
                if los_hours < input_hours:
                    continue

                # Read the full timeseries
                ts = pd.read_csv(ts_path, usecols=['Hours', 'ITEMID', 'VALUE', 'VALUEUOM'])

                # Filter events based on the INPUT time window [0, input_hours)
                ts_truncated = ts[(ts['Hours'] >= 0) & (ts['Hours'] < input_hours)].copy()

                if ts_truncated.empty:
                    continue

                # Create combined ITEMID_UOM identifier
                ts_truncated['ITEMID'] = ts_truncated['ITEMID'].astype(str)
                ts_truncated['VALUEUOM'] = ts_truncated['VALUEUOM'].fillna('').astype(str)
                ts_truncated['ITEMID_UOM'] = ts_truncated['ITEMID'] + '_' + ts_truncated['VALUEUOM']

                # Update unique sets
                itemids.update(ts_truncated['ITEMID'].unique())
                uoms.update(ts_truncated['VALUEUOM'].unique())
                itemid_uoms.update(ts_truncated['ITEMID_UOM'].unique())

                # Select final columns (Keep original + new ID)
                final_ts = ts_truncated[['Hours', 'ITEMID', 'VALUE', 'VALUEUOM', 'ITEMID_UOM']]

                # Save truncated timeseries with input_hours in the name
                output_filename = os.path.join(subject_dir, f'episode{episode_num}_timeseries_{input_hours}.csv')
                final_ts.to_csv(output_filename, index=False)

                # Update counts
                stay_count += 1
                event_count += final_ts.shape[0]
                subject_has_valid_stay = True

            except pd.errors.EmptyDataError: 
                continue
            except Exception as e:
                logger.error(f"Error processing episode {episode_num} in subject {subject}: {e}")
                continue

        if subject_has_valid_stay:
            patient_count += 1

    # Output summary statistics
    logger.info(f"\n--- Truncation Summary ({input_hours}h Input Window) ---")
    logger.info(f"Subjects with >=1 valid stay: {patient_count}")
    logger.info(f"Total valid stays (>= {input_hours}h LOS with events in window): {stay_count}")
    logger.info(f"Total events within {input_hours}h window: {event_count}")
    logger.info(f"Unique ITEMIDs: {len(itemids)}")
    logger.info(f"Unique VALUEUOMs: {len(uoms)}")
    logger.info(f"Unique (ITEMID_UOM) pairs: {len(itemid_uoms)}")


def main():
    """Main function with command line interface"""
    parser = argparse.ArgumentParser(description='Truncate timeseries to specified input length')
    
    parser.add_argument('--data_path', type=str, default=DATA_ROOT_PATH,
                       help='Root path where subject data is stored')
    parser.add_argument('--input_hours', type=int, default=INPUT_HOURS,
                       help='Hours of input data to keep')
    
    args = parser.parse_args()
    
    print("Starting Step 4: Truncate Timeseries")
    print("=" * 50)
    print(f"Data Path: {args.data_path}")
    print(f"Input Hours: {args.input_hours}")
    print("=" * 50)
    
    # Validate paths
    if not os.path.exists(args.data_path):
        print(f"Error: Data path does not exist: {args.data_path}")
        print("Please run Steps 1-3 first.")
        return
    
    if args.input_hours <= 0:
        print("Error: input_hours must be a positive integer.")
        return

    logger.info(f"Starting truncation process for input_hours = {args.input_hours}...")
    truncate_timeseries(args.data_path, args.input_hours)
    logger.info(f"Finished truncation for input_hours = {args.input_hours}.")
    
    print("âœ“ Timeseries truncation completed successfully!")


if __name__ == '__main__':
    main() 